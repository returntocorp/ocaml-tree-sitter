open Common;
module B = Ast_grammar_normalized;

/* let generate_recursive_parser_atom = (body: B.atom): string => {
   | B.TOKEN(None) => ""
   | B.SYMBOL(name) => name
} */
let generate_recursive_parser_simple = ((name, body): B.rule): string => {
   switch(body) {
   | B.SIMPLE(B.ATOM(B.TOKEN(None))) => {
         /* Leaf node */
         spf("
      | J.Object([(\"type\", J.String(\"%s\")),
                  (\"children\", _)]) => \"%s\"",
         name,
         name)
      }
   /* | B.SIMPLE(B.SEQ(ls)) => {
      let array_items = String.concat("", List.map(generate_recursive_parser_atom, ls));
      spf("
      | J.Object([("type", J.String("expression_statement")),
                ("children", %s

      )]) => Expression_statement(parse_expression_statement(xs))
      ", array_items)
   } */
   | _ => ""
   }
}

let generate_parser_func = (rules): string => {
   let simple_rules = List.filter(((_, rule_body)) => {
      switch(rule_body) {
      | B.SIMPLE(B.ATOM(B.TOKEN(None))) => true
      | B.SIMPLE(B.SEQ(_)) => true
      | _ => false
      }
   }, rules);
   let parser_simple_strings = List.map(generate_recursive_parser_simple, simple_rules);
   let parser_func_body = spf("
let rec parse_body = (json: J.json_type): cst_node => {
   switch(json) {%s
    | _ =>  Comment(\"Todo: IMPLEMENT THIS CST NODE TYPE\")
    };
}\n"
   , String.concat("", parser_simple_strings));
   parser_func_body
}

let codegen = (rules, generated_cst_filename: string): string => {
   let header = spf(
"/* DO NOT MODIFY MANUALLY:
Auto-generated by codegen_json_reader*/
open %s
open Common;
module J = Json_type;
let error = (s, json) => failwith(spf(\"Wrong format: %s, got: %s\",s,Json_io.string_of_json(json)));\n",
   generated_cst_filename, "%s", "%s");

   let main = "
   and parse_children = (xs: J.json_type): list(cst_node) => {
    switch(xs) {
    | J.Array(xs) => List.map(parse_body, xs)
    | _ => error(\"Top parse_children\", xs)
    }
}\n";

   let entrypoint = "/*****************************************************************************/
/* Entrypoint */
/*****************************************************************************/
let parse = (file): program_cst => {
    let json = Json_io.load_json(file);
    switch(json) {
    | J.Object(xs) => {
      let children = List.assoc(\"children\",xs);
      parse_children(children)
    }
    | _ => error(\"Toplevel\", json);
    }
}";

   /*
      TODO-s
      Structure of generated code:
      - recursive parser for complex types
      - parse_body
   */
   header ++ generate_parser_func(rules) ++ main ++ entrypoint;
}